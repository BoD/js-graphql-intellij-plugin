/*
    The MIT License (MIT)

    Copyright (c) 2015 Andreas Marek and Contributors

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do
    so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
    LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
package com.intellij.lang.jsgraphql.types.execution;

import com.google.common.collect.ImmutableList;
import com.intellij.lang.jsgraphql.types.PublicApi;
import com.intellij.lang.jsgraphql.types.language.Argument;
import com.intellij.lang.jsgraphql.types.language.Field;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.function.Consumer;

import static com.intellij.lang.jsgraphql.types.Assert.assertNotEmpty;

/**
 * This represent all Fields in a query which overlap and are merged into one.
 * This means they all represent the same field actually when the query is executed.
 * <p>
 * Example query with more than one Field merged together:
 *
 * <pre>
 * {@code
 *
 *      query Foo {
 *          bar
 *          ...BarFragment
 *      }
 *
 *      fragment BarFragment on Query {
 *          bar
 *      }
 * }
 * </pre>
 * <p>
 * Another example:
 * <pre>
 * {@code
 *     {
 *          me{fistName}
 *          me{lastName}
 *     }
 * }
 * </pre>
 * <p>
 * Here the me field is merged together including the sub selections.
 * <p>
 * A third example with different directives:
 * <pre>
 * {@code
 *     {
 *          foo @someDirective
 *          foo @anotherDirective
 *     }
 * }
 * </pre>
 * These examples make clear that you need to consider all merged fields together to have the full picture.
 * <p>
 * The actual logic when fields can successfully merged together is implemented in {#com.intellij.lang.jsgraphql.types.validation.rules.OverlappingFieldsCanBeMerged}
 */
@PublicApi
public class MergedField {

  private final ImmutableList<Field> fields;
  private final Field singleField;

  private MergedField(List<Field> fields) {
    assertNotEmpty(fields);
    this.fields = ImmutableList.copyOf(fields);
    this.singleField = fields.get(0);
  }

  /**
   * All merged fields have the same name.
   * <p>
   * WARNING: This is not always the key in the execution result, because of possible aliases. See {@link #getResultKey()}
   *
   * @return the name of of the merged fields.
   */
  public String getName() {
    return singleField.getName();
  }

  /**
   * Returns the key of this MergedField for the overall result.
   * This is either an alias or the field name.
   *
   * @return the key for this MergedField.
   */
  public String getResultKey() {
    return singleField.getResultKey();
  }

  /**
   * The first of the merged fields.
   * <p>
   * Because all fields are almost identically
   * often only one of the merged fields are used.
   *
   * @return the fist of the merged Fields
   */
  public Field getSingleField() {
    return singleField;
  }

  /**
   * All merged fields share the same arguments.
   *
   * @return the list of arguments
   */
  public List<Argument> getArguments() {
    return singleField.getArguments();
  }


  /**
   * All merged fields
   *
   * @return all merged fields
   */
  public List<Field> getFields() {
    return fields;
  }

  public static Builder newMergedField() {
    return new Builder();
  }

  public static Builder newMergedField(Field field) {
    return new Builder().addField(field);
  }

  public static Builder newMergedField(List<Field> fields) {
    return new Builder().fields(fields);
  }

  public MergedField transform(Consumer<Builder> builderConsumer) {
    Builder builder = new Builder(this);
    builderConsumer.accept(builder);
    return builder.build();
  }

  public static class Builder {

    private final List<Field> fields;

    private Builder() {
      this.fields = new ArrayList<>();
    }

    private Builder(MergedField existing) {
      this.fields = new ArrayList<>(existing.getFields());
    }

    public Builder fields(List<Field> fields) {
      this.fields.addAll(fields);
      return this;
    }

    public Builder addField(Field field) {
      this.fields.add(field);
      return this;
    }

    public MergedField build() {
      return new MergedField(fields);
    }
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MergedField that = (MergedField)o;
    return fields.equals(that.fields);
  }

  @Override
  public int hashCode() {
    return Objects.hashCode(fields);
  }

  @Override
  public String toString() {
    return "MergedField{" +
           "fields=" + fields +
           '}';
  }
}
